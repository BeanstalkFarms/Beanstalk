# Some items included in this schema come from and are inspired by the Messari Generic Schema

enum MarketStatus {
  ACTIVE
  FILLED
  FILLED_PARTIAL
  CANCELLED
  CANCELLED_PARTIAL
  EXPIRED
}

enum PlotSource {
  SOW
  HARVEST
  TRANSFER
}

type Beanstalk @entity {
  " Smart contract address of the protocol's main contract (Factory, Registry, etc) "
  id: ID!

  " Name of the protocol, including version. e.g. Uniswap v3 "
  name: String!

  " Slug of protocol, including version. e.g. uniswap-v3 "
  slug: String!

  " Version of the subgraph schema, in SemVer format (e.g. 1.0.0) "
  schemaVersion: String!

  " Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) "
  subgraphVersion: String!

  " Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) "
  methodologyVersion: String!

  " Timestamp of the latest DiamondCut call "
  lastUpgrade: BigInt!

  " Season specific data "
  seasons: [Season!]! @derivedFrom(field: "beanstalk")

  " Silo level data "
  silo: Silo! @derivedFrom(field: "beanstalk")

  " Field level data "
  field: Field! @derivedFrom(field: "beanstalk")

  " Last season called "
  lastSeason: Int!

  " Array of the addresses for all active farmers in the silo "
  activeFarmers: [String!]!

  " Array of the addresses for all farmers that had silo transfers and need stalk/seeds/roots updated "
  farmersToUpdate: [String!]!
}

# An entity that holds season level data
type Season @entity {
  " Season Number"
  id: ID!

  " Beanstalk Contract Address "
  beanstalk: Beanstalk!

  " Season number in Int form for sorting "
  season: Int!

  " Block timestamp when sunrise was called "
  createdAt: BigInt!

  " Price of BEAN during sunrise "
  price: BigDecimal!

  " Total Bean supply "
  beans: BigInt!

  " Bean Market Cap "
  marketCap: BigDecimal!

  " Time weighted deltaB "
  deltaB: BigInt!

  " Change in Bean supply "
  deltaBeans: BigInt!

  " Amount of Beans minted during sunrise "
  rewardBeans: BigInt!

  " Amount of Beans paid to sunrise caller "
  incentiveBeans: BigInt!

  " New harvestable index for the season "
  harvestableIndex: BigInt!
}

type Silo @entity {
  "Address for the farmer or Beanstalk"
  id: ID!
  "Beanstalk diamond address"
  beanstalk: Beanstalk!
  "Farmer address if applicable"
  farmer: Farmer
  "Tokens whitelisted for deposit within the silo"
  whitelistedTokens: [String!]!
  "Link to all silo assets currently associated with this silo"
  assets: [SiloAsset!]! @derivedFrom(field: "silo")
  "Current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Current stalk balance"
  stalk: BigInt!
  "Current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  "Current seeds balance"
  seeds: BigInt!
  "Current roots balance"
  roots: BigInt!
  "Cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Current number of active farmers deposited in the silo"
  activeFarmers: Int!
  "Link to hourly snapshot data"
  hourlySnapshots: [SiloHourlySnapshot!]! @derivedFrom(field: "silo")
  "Link to daily snapshot data"
  dailySnapshots: [SiloDailySnapshot!]! @derivedFrom(field: "silo")
}

type SiloHourlySnapshot @entity {
  "ID of silo-Unix Hour Timestamp"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Silo associated with the snapshot"
  silo: Silo!
  "Point in time current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Point in time current stalk balance"
  stalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  "Point in time current seeds balance"
  seeds: BigInt!
  "Point in time current roots balance"
  roots: BigInt!
  "Point in time cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Point in time current number of active farmers deposited in the silo"
  activeFarmers: Int!
  "Point in time delta BDV of all deposited assets"
  deltaDepositedBDV: BigInt!
  "Point in time delta stalk balance"
  deltaStalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  deltaPlantableStalk: BigInt!
  "Point in time delta seeds balance"
  deltaSeeds: BigInt!
  "Point in time delta roots balance"
  deltaRoots: BigInt!
  "Point in time delta total for bean mints sent to the silo"
  deltaBeanMints: BigInt!
  "Point in time delta number of active farmers deposited in the silo"
  deltaActiveFarmers: Int!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloDailySnapshot @entity {
  "ID of silo-Unix Hour Timestamp"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Silo associated with the snapshot"
  silo: Silo!
  "Point in time current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Point in time current stalk balance"
  stalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  "Point in time current seeds balance"
  seeds: BigInt!
  "Point in time current roots balance"
  roots: BigInt!
  "Point in time cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Point in time current number of active farmers deposited in the silo"
  activeFarmers: Int!
  "Point in time delta BDV of all deposited assets"
  deltaDepositedBDV: BigInt!
  "Point in time delta stalk balance"
  deltaStalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  deltaPlantableStalk: BigInt!
  "Point in time delta seeds balance"
  deltaSeeds: BigInt!
  "Point in time delta roots balance"
  deltaRoots: BigInt!
  "Point in time delta total for bean mints sent to the silo"
  deltaBeanMints: BigInt!
  "Point in time delta number of active farmers deposited in the silo"
  deltaActiveFarmers: Int!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloAsset @entity {
  "Silo ID - Asset Token Address"
  id: ID!
  "Silo for this asset"
  silo: Silo!
  "Token address for this asset"
  token: String!
  "Current BDV of deposits"
  depositedBDV: BigInt!
  "Current Token amount of deposits"
  depositedAmount: BigInt!
  "Current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!
  "Current internal (farm) balance of the asset"
  farmAmount: BigInt!
  "Link to hourly snapshot data"
  hourlySnapshots: [SiloAssetHourlySnapshot!]! @derivedFrom(field: "siloAsset")
  "Link to daily snapshot data"
  dailySnapshots: [SiloAssetDailySnapshot!]! @derivedFrom(field: "siloAsset")
}

type SiloAssetHourlySnapshot @entity {
  "Silo Asset ID - Unix Timestamp"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Silo asset associated with this snapshot"
  siloAsset: SiloAsset!
  "Point in time current BDV of deposits"
  depositedBDV: BigInt!
  "Point in time current Token amount of deposits"
  depositedAmount: BigInt!
  "Point in time current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!
  "Point in time current internal (farm) balance of the asset"
  farmAmount: BigInt!
  "Point in time delta BDV of deposits"
  deltaDepositedBDV: BigInt!
  "Point in time delta Token amount of deposits"
  deltaDepositedAmount: BigInt!
  "Point in time delta Token amount of silo withdrawals"
  deltaWithdrawnAmount: BigInt!
  "Point in time delta internal (farm) balance of the asset"
  deltaFarmAmount: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloAssetDailySnapshot @entity {
  "Silo Asset ID - Unix Timestamp"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Silo asset associated with this snapshot"
  siloAsset: SiloAsset!
  "Point in time current BDV of deposits"
  depositedBDV: BigInt!
  "Point in time current Token amount of deposits"
  depositedAmount: BigInt!
  "Point in time current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!
  "Point in time current internal (farm) balance of the asset"
  farmAmount: BigInt!
  "Point in time delta BDV of deposits"
  deltaDepositedBDV: BigInt!
  "Point in time delta Token amount of deposits"
  deltaDepositedAmount: BigInt!
  "Point in time delta Token amount of silo withdrawals"
  deltaWithdrawnAmount: BigInt!
  "Point in time delta internal (farm) balance of the asset"
  deltaFarmAmount: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloYield @entity {
  "Season of data points"
  id: ID!
  "Sortable int field for season"
  season: Int!
  "Beta used for EMA"
  beta: BigDecimal!
  "u used for EMA"
  u: Int!
  "Bean EMA for season"
  beansPerSeasonEMA: BigDecimal!
  "Bean APY for two seeds per BDV"
  twoSeedBeanAPY: BigDecimal!
  "Stalk APY for two seeds per BDV"
  twoSeedStalkAPY: BigDecimal!
  "Bean APY for four seeds per BDV"
  fourSeedBeanAPY: BigDecimal!
  "Stalk APY for four seeds per BDV"
  fourSeedStalkAPY: BigDecimal!
  "Unix timestamp of update"
  createdAt: BigInt!
}

type Field @entity {
  " Contract address for this field or farmer "
  id: ID!
  "Contract address of beanstalk"
  beanstalk: Beanstalk!
  "Farmer address if applicable"
  farmer: Farmer
  "Current season number"
  season: Int!
  "Current temperature"
  temperature: Int!
  "Rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Cumulative number of unique sowers"
  numberOfSowers: Int!
  "Cumulative number of sows"
  numberOfSows: Int!
  "Cumulative total of sown beans"
  sownBeans: BigInt!
  "Array of current non-harvestable plots"
  plotIndexes: [BigInt!]!
  "Current outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Current harvestable pods"
  harvestablePods: BigInt!
  "Cumulative harvested pods"
  harvestedPods: BigInt!
  "Current amount of soil available"
  soil: BigInt!
  "Current pod index"
  podIndex: BigInt!
  "Current pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!
  "Link to hourly snapshot data"
  hourlySnapshots: [FieldHourlySnapshot!]! @derivedFrom(field: "field")
  "Link to daily snapshot data"
  dailySnapshots: [FieldDailySnapshot!]! @derivedFrom(field: "field")
}

type FieldHourlySnapshot @entity {
  "Field ID - Unix Timestamp"
  id: ID!
  "Field associated with this snapshot"
  field: Field!
  "Season"
  season: Int!
  "Point in time temperature"
  temperature: Int!
  "Point in time rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Point in time cumulative number of unique sowers"
  numberOfSowers: Int!
  "Point in time cumulative number of sows"
  numberOfSows: Int!
  "Point in time cumulative total of sown beans"
  sownBeans: BigInt!
  "Point in time outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Point in time harvestable pods"
  harvestablePods: BigInt!
  "Point in time cumulative harvested pods"
  harvestedPods: BigInt!
  "Point in time amount of soil remaining"
  soil: BigInt!
  "Point in time pod index"
  podIndex: BigInt!
  "Point in time pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!
  "Point in time delta number of unique sowers"
  deltaNumberOfSowers: Int!
  "Point in time delta number of sows"
  deltaNumberOfSows: Int!
  "Point in time delta total of sown beans"
  deltaSownBeans: BigInt!
  "Point in time delta non-harvestable pods"
  deltaUnharvestablePods: BigInt!
  "Point in time delta harvestable pods"
  deltaHarvestablePods: BigInt!
  "Point in time delta harvested pods"
  deltaHarvestedPods: BigInt!
  "Point in time amount of soil issued"
  issuedSoil: BigInt!
  "Number of blocks between sunrise and soil being sold out"
  blocksToSoldOutSoil: BigInt!
  "Bool flag if soil sold out for the season"
  soilSoldOut: Boolean!
  "Creation Block Number"
  blockNumber: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type FieldDailySnapshot @entity {
  "Field ID - Unix Timestamp"
  id: ID!
  "Field associated with this snapshot"
  field: Field!
  "Last season in the snapshot"
  season: Int!
  "Point in time temperature"
  temperature: Int!
  "Point in time rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Point in time cumulative number of unique sowers"
  numberOfSowers: Int!
  "Point in time cumulative number of sows"
  numberOfSows: Int!
  "Point in time cumulative total of sown beans"
  sownBeans: BigInt!
  "Point in time outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Point in time harvestable pods"
  harvestablePods: BigInt!
  "Point in time delta harvested pods"
  harvestedPods: BigInt!
  "Point in time amount of soil remaining"
  soil: BigInt!
  "Point in time pod index"
  podIndex: BigInt!
  "Point in time pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!
  "Point in time delta number of unique sowers"
  deltaNumberOfSowers: Int!
  "Point in time delta number of sows"
  deltaNumberOfSows: Int!
  "Point in time delta total of sown beans"
  deltaSownBeans: BigInt!
  "Point in time delta non-harvestable pods"
  deltaUnharvestablePods: BigInt!
  "Point in time delta harvestable pods"
  deltaHarvestablePods: BigInt!
  "Point in time delta harvested pods"
  deltaHarvestedPods: BigInt!
  "Point in time amount of soil issued"
  issuedSoil: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

# ---===== Farmer Account Entities =====---

type Farmer @entity {
  "Address for the farmer"
  id: ID!
  silo: Silo @derivedFrom(field: "farmer")
  deposits: [SiloDeposit!]! @derivedFrom(field: "farmer")
  withdraws: [SiloWithdraw!]! @derivedFrom(field: "farmer")
  field: Field @derivedFrom(field: "farmer")
  plots: [Plot!]! @derivedFrom(field: "farmer")
  listings: [PodListing!]! @derivedFrom(field: "farmer")
  orders: [PodOrder!]! @derivedFrom(field: "farmer")
  fills: [PodFill!]! @derivedFrom(field: "to")
  fertilizers: [FertilizerBalance!]! @derivedFrom(field: "farmer")
}

type SiloDeposit @entity {
  """
  Pre Silo V3:
  Account - Token Address - Season

  Post Silo-V3:
  Account - Token Address - Stem
  """
  id: ID!
  "Farmer address"
  farmer: Farmer!
  "Token Address"
  token: String!
  "Season of deposit"
  season: Int!
  "Stem of deposit - Introduced in Silo V3"
  stem: BigInt
  "Current token amount deposited"
  amount: BigInt!
  "Original token amount deposited"
  depositedAmount: BigInt!
  "Token amount withdrawn"
  withdrawnAmount: BigInt!
  "Current BDV of the deposit"
  bdv: BigInt!
  "Original deposited BDV"
  depositedBDV: BigInt!
  "Withdrawn BDV"
  withdrawnBDV: BigInt!
  "Transaction hashes for multiple deposits in one season"
  hashes: [String!]!
  "Timestamp of first deposit"
  createdAt: BigInt!
  "Timestamp when last updated"
  updatedAt: BigInt!
}

type SiloWithdraw @entity {
  "Account - Deposit Token - Current Season"
  id: ID!
  "Farmer address"
  farmer: Farmer!
  "Token address"
  token: String!
  "Season withdrawal initiated"
  withdrawSeason: Int!
  "Season when withdrawal can be claimed"
  claimableSeason: Int!
  "Flag for if this has been claimed"
  claimed: Boolean!
  "Token amount withdrawn"
  amount: BigInt!
  "Transaction hash of withdrawal"
  hashes: [String!]!
  "Timestamp created"
  createdAt: BigInt!
}

type Plot @entity {
  "Plot index"
  id: ID!
  "Field to which this plot belongs"
  field: Field!
  "Farmer who owns this plot"
  farmer: Farmer!
  "Transaction source for this plot"
  source: PlotSource!
  "Associated plot listing"
  listing: PodListing
  "Season when created"
  season: Int!
  "Creation transaction hash"
  creationHash: String!
  "Timestamp of creation"
  createdAt: BigInt!
  "Timestamp when updated"
  updatedAt: BigInt!
  "Plot Index"
  index: BigInt!
  "Beans used to sow, if any"
  beans: BigInt!
  "Total pods in plot"
  pods: BigInt!
  "Total pods that were sown, if any"
  sownPods: BigInt!
  "Temperature when the plot was sown"
  temperature: Int!
  "Number of pods harvestable"
  harvestablePods: BigInt!
  "Number of pods harvested"
  harvestedPods: BigInt!
  "Flag for if plot is fully harvested"
  fullyHarvested: Boolean!
}

type PodMarketplace @entity {
  " Contract address of beanstalk "
  id: ID!
  "Current season of the marketplace"
  season: Int!
  "Indexes of actively listed plots"
  listingIndexes: [BigInt!]!
  "Active pod order IDs"
  orders: [PodOrder!]!
  "All historical listings"
  allListings: [PodListing!]! @derivedFrom(field: "podMarketplace")
  "All historical orders"
  allOrders: [PodOrder!]! @derivedFrom(field: "podMarketplace")
  "All historical marketplace fills"
  fills: [PodFill!]! @derivedFrom(field: "podMarketplace")
  "Current cumulative pods listed for sale"
  listedPods: BigInt!
  "Current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Current amount of total pods listed"
  availableListedPods: BigInt!
  "Current cumulative pod orders created"
  orderedPods: BigInt!
  "Current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Current cumulative pod orders cancelled"
  cancelledOrderedPods: BigInt!
  "Cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Cumulative bean volume between listings and orders"
  beanVolume: BigInt!
  "Link to hourly snapshot data"
  hourlySnapshots: [PodMarketplaceHourlySnapshot!]! @derivedFrom(field: "podMarketplace")
  "Link to daily snapshot data"
  dailySnapshots: [PodMarketplaceDailySnapshot!]! @derivedFrom(field: "podMarketplace")
}

type PodMarketplaceHourlySnapshot @entity {
  "Marketplace ID - Unix Timestamp"
  id: ID!
  "Point in time latest season"
  season: Int!
  "Marketplace associated with snapshot"
  podMarketplace: PodMarketplace!
  "Point in time current cumulative pods listed for sale"
  listedPods: BigInt!
  "Point in time current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Point in time current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Point in time current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Point in time current amount of total pods listed"
  availableListedPods: BigInt!
  "Point in time current cumulative pod orders created"
  orderedPods: BigInt!
  "Point in time current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Point in time current cumulative pod orders cancelled"
  cancelledOrderedPods: BigInt!
  "Point in time current cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Point in time current cumulative bean volume between listings and orders"
  beanVolume: BigInt!
  "Point in time current delta pods listed for sale"
  deltaListedPods: BigInt!
  "Point in time current delta pod listings filled"
  deltaFilledListedPods: BigInt!
  "Point in time current delta pod listings that expired"
  deltaExpiredListedPods: BigInt!
  "Point in time current delta pod listings that were cancelled"
  deltaCancelledListedPods: BigInt!
  "Point in time current delta of total pods listed"
  deltaAvailableListedPods: BigInt!
  "Point in time current delta pod orders created"
  deltaOrderedPods: BigInt!
  "Point in time current delta pod orders filled"
  deltaFilledOrderedPods: BigInt!
  "Point in time current delta pod orders cancelled"
  deltaCancelledOrderedPods: BigInt!
  "Point in time current delta pod volume between listings and orders"
  deltaPodVolume: BigInt!
  "Point in time current delta bean volume between listings and orders"
  deltaBeanVolume: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type PodMarketplaceDailySnapshot @entity {
  "Marketplace ID - Unix Timestamp"
  id: ID!
  "Point in time latest season"
  season: Int!
  "Marketplace associated with snapshot"
  podMarketplace: PodMarketplace!
  "Point in time current cumulative pods listed for sale"
  listedPods: BigInt!
  "Point in time current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Point in time current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Point in time current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Point in time current amount of total pods listed"
  availableListedPods: BigInt!
  "Point in time current cumulative pod orders created"
  orderedPods: BigInt!
  "Point in time current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Point in time current cumulative pod orders cancelled"
  cancelledOrderedPods: BigInt!
  "Point in time current cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Point in time current cumulative bean volume between listings and orders"
  beanVolume: BigInt!
  "Point in time current delta pods listed for sale"
  deltaListedPods: BigInt!
  "Point in time current delta pod listings filled"
  deltaFilledListedPods: BigInt!
  "Point in time current delta pod listings that expired"
  deltaExpiredListedPods: BigInt!
  "Point in time current delta pod listings that were cancelled"
  deltaCancelledListedPods: BigInt!
  "Point in time current delta of total pods listed"
  deltaAvailableListedPods: BigInt!
  "Point in time current delta pod orders created"
  deltaOrderedPods: BigInt!
  "Point in time current delta pod orders filled"
  deltaFilledOrderedPods: BigInt!
  "Point in time current delta pod orders cancelled"
  deltaCancelledOrderedPods: BigInt!
  "Point in time current delta pod volume between listings and orders"
  deltaPodVolume: BigInt!
  "Point in time current delta bean volume between listings and orders"
  deltaBeanVolume: BigInt!
  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type PodListing @entity {
  ######################## Identifiers ########################

  """
  The PodListing ID is a unique subgraph ID: `{account}-{index}"

  The on-chain identifier for a PodListing is the `index`.
  """
  id: ID!

  "Marketplace used for listing"
  podMarketplace: PodMarketplace!

  "Historical ID for joins"
  historyID: String!

  "Plot being Listed."
  plot: Plot!

  "The Farmer that created the PodListing."
  farmer: Farmer!

  ######################## Configuration ########################

  """
  The absolute index of the listed Plot in the Pod Line.

  Measured from the front, so the Listing contains all Pods between
  (index) and (index + totalAmount).

  An example where the podLine is 50,000 but the index is 150,000:
     0         the first Pod issued
     100,000   harvestableIndex
     150,000   index
  """
  index: BigInt!

  """
  The position within the Plot from which to sell Pods.

  0 <= `start` <= (plot size - `amount`)
  """
  start: BigInt!

  "Where Beans are sent when the PodListing is Filled. See `FarmToMode`."
  mode: Int!

  ######################## Constraints ########################

  """
  When the `harvestableIndex` reaches this number, the Listing becomes EXPIRED.
  """
  maxHarvestableIndex: BigInt!

  "Minimum number of Beans required to perform a Fill."
  minFillAmount: BigInt!

  ######################## Pricing ########################

  """
  The Pricing Type states whether this PodListing uses FIXED or DYNAMIC pricing.

  null = V1 FIXED  = use `pricePerPod`
  0    = V2 FIXED  = use `pricePerPod`
  1    = V2 DYNAMIC = use `pricingFunction`
  """
  pricingType: Int

  """
  [V1] The FIXED price per Pod denominated in Beans.

  Ex. `pricePerPod = 10000` indicates a price of 0.01 Beans per Pod.

  If `pricingType = 1`, this field is set to `0` and should be ignored.
  """
  pricePerPod: Int!

  """
  [V2] The FIXED or DYNAMIC pricing function, encoded as bytes.

  This must be decoded client-side, see `LibPolynomial.sol` for more info.
  """
  pricingFunction: Bytes

  ######################## Amounts [Relative to Original] ########################

  """
  The original index from the first emission of PodListingCreated in a chain.

  If `originalIndex !== index`, then this PodListing was created when a parent
  PodListing was partially filled.
  """
  originalIndex: BigInt!

  """
  The total number of Pods listed during the first emission of PodListingCreated.
  """
  originalAmount: BigInt!

  """
  The amount of Pods Filled since the initial PodListing was Created.

  `0 <= filled <= originalAmount`
  """
  filled: BigInt!

  ######################## Amounts [Relative to Child] ########################

  """
  The maximum amount of Pods remaining to be sold by *this* PodListing.

  When this PodListing is Filled or Cancelled, `amount` does NOT change.
  """
  amount: BigInt!

  """
  The number of Pods remaining in *this* PodListing.

  When a Fill occurs, `remainingAmount` is decremented on this PodListing. A new
  PodListing is created with an updated `index` and `amount` equal to this
  PodListing's remainingAmount.

  If this PodListing has NOT been Filled: `remainingAmount = amount`
  If this PodListing has been Filled: `remainingAmount < amount`
  If this PodListing has been Cancelled: `remainingAmount = 0`
  """
  remainingAmount: BigInt!

  """
  The number of Pods purchased from *this* PodListing.

  If not yet Filled or the PodListing is CANCELLED: `filledAmount = 0`
  """
  filledAmount: BigInt!

  """
  The number of Pods that were remaining in *this* PodListing when it was Cancelled.
  """
  cancelledAmount: BigInt!

  ######################## Activity ########################

  "Any Fills associated with this PodListing."
  fill: PodFill

  ######################## Metadata ########################

  "Current market status of listing"
  status: MarketStatus!

  "Timestamp of PodListing creation."
  createdAt: BigInt!

  "Timestamp of last update to this PodListing, including Fills and Cancellations."
  updatedAt: BigInt!

  "Transaction hash when this PodListing entity was created."
  creationHash: String!
}

type PodOrder @entity {
  ######################## Identifiers ########################

  """
  The PodOrder ID matchces the `id` stored on-chain:

  `keccak256(abi.encodePacked(account, pricePerPod, maxPlaceInLine, minFillAmount))`
  """
  id: ID!

  """
  Historical ID for joins: `{account}-{createdAt}`
  """
  historyID: String!

  "The Farmer that created the Pod Order."
  farmer: Farmer!

  "Marketplace used for Pod Order."
  podMarketplace: PodMarketplace!

  ######################## Constraints ########################

  """
  The Farmer is willing to buy any Pod that is before maxPlaceInLine at pricePerPod.
  As the Pod Line moves, this value stays the same because new Pods meet the criteria.
  """
  maxPlaceInLine: BigInt!

  "Minimum number of Pods required to perform a Fill."
  minFillAmount: BigInt!

  ######################## Pricing ########################

  """
  The Pricing Type states whether this PodOrder uses FIXED or DYNAMIC pricing.

  null = V1 FIXED  = use `pricePerPod`
  0    = V2 FIXED  = use `pricePerPod`
  1    = V2 DYNAMIC = use `pricingFunction`
  """
  pricingType: Int

  """
  [V1] The FIXED price per Pod denominated in Beans.

  Ex. `pricePerPod = 10000` indicates a price of 0.01 Beans per Pod.

  If `pricingType = 1`, this field is initialized to `0` and should be ignored.
  """
  pricePerPod: Int!

  """
  [V2] The FIXED or DYNAMIC pricing function, encoded as bytes.

  This must be decoded client-side, see `LibPolynomial.sol` for more info.

  null    = V1 FIXED    = use `pricePerPod`
  "0x"    = V2 FIXED    = use `pricePerPod`
  "0x..." = V2 DYNAMIC  = use `pricingFunction`
  """
  pricingFunction: Bytes

  ######################## Amounts ########################

  """
  The original number of Pods requested by this PodOrder.

  Does NOT change as Fills occur.
  Not deterministic for PodOrders with pricingType = DYNAMIC.

  If pricingType = FIXED:
    Set to the number of Pods which can be purchased by the Order.
    If FIXED (V1): `amount` field emitted in PodOrderCreated.
    If FIXED (V2): `amount / pricePerPod` fields emitted in PodOrderCreated.

  If pricingType = DYNAMIC:
    Set to `0`. The number of Pods that will be provided is unknown, since
    the price is calculated based on the place in line of supplied Pods.
  """
  podAmount: BigInt!

  """
  The current number of Pods that have been purchased by this PodOrder.

  Increases during each subsequent Fill.
  If pricingType = FIXED: `0 <= podAmountFilled <= podAmount`
  If pricingType = DYNAMIC: No constraint, since `podAmount` is unknown.

  Upon PodOrder cancellation, this value is locked.
  """
  podAmountFilled: BigInt!

  """
  The original number of Beans locked in the PodOrder.

  Does NOT change as Fills occur.
  Always deterministic, since the Farmer must lock Beans for PodOrder fulfillment.

  If FIXED (V1): `amount * pricePerPod` fields emitted in PodOrderCreated.
  If FIXED (V2): `amount` field emitted in PodOrderCreated.
  If DYNAMIC (V2): `amount` field emitted in PodOrderCreated.
  """
  beanAmount: BigInt!

  """
  The current number of Beans spent to acquire Pods.

  Increases during each subsequent Fill:
  `0 <= beanAmountFilled <= beanAmount`

  Upon PodOrder cancellation, this value is locked.
  """
  beanAmountFilled: BigInt!

  ######################## Activity ########################

  "All Fills associated with this PodOrder."
  fills: [PodFill!]!

  ######################## Metadata ########################

  "Current status of order."
  status: MarketStatus!

  "Timestamp of PodOrder creation."
  createdAt: BigInt!

  "Timestamp of last PodOrder update. Changes when a PodOrder is Filled or Cancelled."
  updatedAt: BigInt!

  "Transaction hash when this PodOrder entity was created."
  creationHash: String!
}

type PodFill @entity {
  "Beanstalk address - Order/Listing index - transaction hash"
  id: ID!
  "Marketplace associated with this fill"
  podMarketplace: PodMarketplace!
  "Creation timestamp"
  createdAt: BigInt!
  "Associated listing, if any"
  listing: PodListing
  "Associated order, if any"
  order: PodOrder
  "Account fulfilling the order"
  from: String! # These are already referenced via the listing and order entities.
  "Account filling the order"
  to: Farmer!
  "Number of pods filled"
  amount: BigInt!
  "Index of plot transferred"
  index: BigInt!
  "Start of plot transferred"
  start: BigInt!
  "Total beans used to fill listing/order"
  costInBeans: BigInt
}

##################################
##### Fertilizer Entities #####
##################################

# Global Fertilizer state for tracking
type Fertilizer @entity {
  "Token address for fert"
  id: ID!
  "Total overall suppy of fert tokens"
  supply: BigInt!
  tokens: [FertilizerToken!]! @derivedFrom(field: "fertilizer")
}

# Id-level Fertilizer entity
type FertilizerToken @entity {
  "Total BPF for purchase"
  id: ID!
  fertilizer: Fertilizer!
  "Total supply for this Humidity"
  supply: BigInt!
  "Humidity paid for this ID"
  humidity: BigDecimal!
  "Ending BPF on creation"
  endBpf: BigInt!
  "Starting BPF on creation"
  startBpf: BigInt!
  "Season created"
  season: Int!
  balances: [FertilizerBalance!]! @derivedFrom(field: "fertilizerToken")
}

type FertilizerBalance @entity {
  "Fertilizer Token - Farmer address"
  id: ID!
  fertilizerToken: FertilizerToken!
  farmer: Farmer!
  "Current balance of token"
  amount: BigInt!
}

type FertilizerYield @entity {
  "Season of data points"
  id: ID!
  "Current season"
  season: Int!
  "Current humidity"
  humidity: BigDecimal!
  "Current outstanding fert"
  outstandingFert: BigInt!
  "Current Bean EMA"
  beansPerSeasonEMA: BigDecimal!
  "BPF delta"
  deltaBpf: BigDecimal!
  "Simplified APY for new Fert"
  simpleAPY: BigDecimal!
  "Block timestamp at creation"
  createdAt: BigInt!
}

##################################
##### Event-Level Data #####
##################################

### We need to add these in

"""
An event is any user action that occurs in a protocol. Generally, they are Ethereum events
emitted by a function in the smart contracts, stored in transaction receipts as event logs.
However, some user actions of interest are function calls that don't emit events. For example,
the deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still
store them as events, although they are not technically Ethereum events emitted by smart
contracts.
"""
interface SiloEvent {
  " { Event type }-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

interface FieldEvent {
  " { Event type }-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

interface MarketplaceEvent {
  " { Event type }-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodTransfer implements FieldEvent @entity(immutable: true) {
  " podtransfer-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Address that received the pods "
  to: String!
  " Address that sent the pods "
  from: String!
  " Index of the pods sent"
  index: BigInt!
  " Total pods being sent"
  pods: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type Harvest implements FieldEvent @entity(immutable: true) {
  "harvest-{ Transaction hash }-{ Log index } "
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Address harvesting beans "
  farmer: String!
  " Plots being harvested "
  plots: [BigInt!]!
  " Total beans harvested "
  beans: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type Chop implements SiloEvent @entity(immutable: true) {
  "chop-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Address chopping "
  farmer: String!
  " Unripe token being chopped "
  unripe: String!
  " Amount being chopped"
  amount: BigInt!
  " Underlying token "
  underlying: String!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type Incentive implements SiloEvent @entity(immutable: true) {
  "incentive-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Address incentivized "
  caller: String!
  " Amount minted as incentive"
  amount: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type Reward implements SiloEvent @entity(immutable: true) {
  "reward-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Season of reward "
  season: Int!
  " Amount minted to pod line"
  toField: BigInt!
  " Amount minted to silo"
  toSilo: BigInt!
  " Amount minted to fertilizer"
  toFertilizer: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type MetapoolOracle implements SiloEvent @entity(immutable: true) {
  "metapoolOracle-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Season of oracle "
  season: Int!
  " DeltaB for season"
  deltaB: BigInt!
  " Cumulative balance A"
  balanceA: BigInt!
  " Cumulative balance B"
  balanceB: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type AddDeposit implements SiloEvent @entity(immutable: true) {
  "addDeposit-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Account adding deposit"
  account: String!
  " Token added"
  token: String!
  " Season of deposit added "
  season: Int!
  " Stem of deposit added "
  stem: BigInt
  " Amount of token added "
  amount: BigInt!
  " BDV of the deposit "
  bdv: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type RemoveDeposit implements SiloEvent @entity(immutable: true) {
  "removeDeposit-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Account removing deposit"
  account: String!
  " Token removed"
  token: String!
  " Season of deposit removed "
  season: Int!
  " Stem of deposit removed "
  stem: BigInt
  " Amount of token removed "
  amount: BigInt!
  " BDV of deposit removed "
  bdv: BigInt
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type StalkChange implements SiloEvent @entity(immutable: true) {
  "stalkChange-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Account removing deposit"
  account: String!
  " Token removed"
  delta: BigInt!
  " Season when the change happened "
  season: Int!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type SeedChange implements SiloEvent @entity(immutable: true) {
  "seedChange-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Account removing deposit"
  account: String!
  " Token removed"
  delta: BigInt!
  " Season when the change happened "
  season: Int!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodListingCreated implements MarketplaceEvent @entity(immutable: true) {
  "podListingCreated-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  " Account creating the listing"
  account: String!
  " Index of the plot listed"
  index: BigInt!
  " Start value of the plot listed "
  start: BigInt!
  "Amount of pods listed"
  amount: BigInt!
  "Price per pod"
  pricePerPod: Int!
  "Max index for listing"
  maxHarvestableIndex: BigInt!
  "Minimum fill amount"
  minFillAmount: BigInt!
  "Claim to location"
  mode: Int!
  "Pricing Function Data"
  pricingFunction: Bytes
  "Pricing Type"
  pricingType: Int
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodListingFilled implements MarketplaceEvent @entity(immutable: true) {
  "podListingFilled-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  "Account selling pods"
  from: String!
  "Account buying pods"
  to: String!
  "Index of the plot transferred"
  index: BigInt!
  "Start of the plot transferred"
  start: BigInt!
  "Number of pods transferred"
  amount: BigInt!
  "Beans paid to fill the listing"
  costInBeans: BigInt
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodListingCancelled implements MarketplaceEvent @entity(immutable: true) {
  "seedChange-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  " Account cancelling listing"
  account: String!
  " Index of plot listing being cancelled"
  index: BigInt!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodOrderCreated implements MarketplaceEvent @entity(immutable: true) {
  "podOrderCreated-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  " Account creating the listing"
  account: String!
  " ID of the pod order"
  orderId: String!
  """
  The represented value emitted with this event changed with BIP-29 at block 15277986
  Pre  BIP-29: The number of pods ordered is emitted
  Post BIP-29: The number of beans supplied for the order is emitted.
  """
  amount: BigInt!
  "Price per pod"
  pricePerPod: Int!
  "Max place in line"
  maxPlaceInLine: BigInt!
  "Pricing Function Data"
  pricingFunction: Bytes
  "Pricing Type"
  pricingType: Int
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodOrderFilled implements MarketplaceEvent @entity(immutable: true) {
  "podOrderFilled-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  "Account selling pods"
  from: String!
  "Account buying pods"
  to: String!
  "Index of the plot transferred"
  index: BigInt!
  "Start of the plot transferred"
  start: BigInt!
  "Number of pods transferred"
  amount: BigInt!
  "Beans paid to fill the order"
  costInBeans: BigInt
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type PodOrderCancelled implements MarketplaceEvent @entity(immutable: true) {
  "podOrderCancelled-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  " Historical ID for joins"
  historyID: String!
  " Account cancelling listing"
  account: String!
  " ID of order cancelled"
  orderId: String!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type WhitelistToken implements SiloEvent @entity(immutable: true) {
  "whitelistToken-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  "Token address whitelisted"
  token: String!
  "Stalk per BDV"
  stalk: BigInt!
  "Seeds per BDV"
  seeds: BigInt!
  "Stalk earned per season"
  stalkPerSeason: BigInt
  "Selector for token"
  selector: String!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}

type DewhitelistToken implements SiloEvent @entity(immutable: true) {
  "dewhitelistToken-{ Transaction hash }-{ Log index }"
  id: ID!
  " Transaction hash of the transaction that emitted this event "
  hash: String!
  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!
  " The protocol this transaction belongs to "
  protocol: Beanstalk!
  "Token address dewhitelisted"
  token: String!
  " Block number of this event "
  blockNumber: BigInt!
  " Timestamp of this event "
  createdAt: BigInt!
}
