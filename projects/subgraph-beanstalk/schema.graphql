# This same entity schema is intended for use across the subgraphs
type Version @entity {
  "= 'subgraph'"
  id: ID!
  "= 'beanstalk'"
  subgraphName: String!
  "Verison number of the subgraph"
  versionNumber: String!
  "Address of Beanstalk protocol"
  protocolAddress: Bytes!
  "Which blockchain is being indexed, i.e. 'ethereum', 'arbitrum', etc."
  chain: String!
}

enum MarketStatus {
  ACTIVE
  FILLED
  FILLED_PARTIAL
  CANCELLED
  CANCELLED_PARTIAL
  EXPIRED
}

enum PlotSource {
  SOW
  TRANSFER
  MARKET
  RESEED_MIGRATED
  CONTRACT_RECEIVER_MIGRATED
}

enum EmaWindow {
  ROLLING_24_HOUR
  ROLLING_7_DAY
  ROLLING_30_DAY
}

type Beanstalk @entity {
  "'beanstalk'"
  id: ID!
  "Bean token address of the protocol"
  token: Bytes!
  "Address of the fertilizer contract"
  fertilizer1155: Bytes
  "Season specific data"
  seasons: [Season!]! @derivedFrom(field: "beanstalk")
  "Silo level data"
  silo: Silo! @derivedFrom(field: "beanstalk")
  "Field level data"
  field: Field! @derivedFrom(field: "beanstalk")
  "Last season called"
  lastSeason: Int!
  "Array of the addresses for all active farmers in the silo"
  activeFarmers: [Bytes!]!
  "Array of the addresses for all farmers that had silo transfers and need stalk/roots updated"
  farmersToUpdate: [Bytes!]!
}

type Season @entity {
  "Season Number"
  id: ID!
  "'beanstalk'"
  beanstalk: Beanstalk!
  "Season number in Int form for sorting"
  season: Int!
  "Block in which the season start was triggered by the sunrise call"
  sunriseBlock: BigInt!
  "Block timestamp when sunrise was called"
  createdAt: BigInt!
  "Price of BEAN during sunrise"
  price: BigDecimal!
  "Total Bean supply"
  beans: BigInt!
  "Beans from L1 which have not migrated yet"
  unmigratedL1Beans: BigInt
  "Bean Market Cap"
  marketCap: BigDecimal!
  "Time weighted deltaB"
  deltaB: BigInt!
  "Change in Bean supply"
  deltaBeans: BigInt!
  "Amount of Beans minted during sunrise"
  rewardBeans: BigInt!
  "Amount of Beans paid to sunrise caller"
  incentiveBeans: BigInt!
}

type Silo @entity {
  "Address for the farmer or Beanstalk contract"
  id: Bytes!
  "'beanstalk'"
  beanstalk: Beanstalk!
  "Farmer address if applicable"
  farmer: Farmer
  "Tokens whitelisted for deposit within the silo"
  whitelistedTokens: [Bytes!]!
  "Tokens that have been removed from the silo deposit whitelist"
  dewhitelistedTokens: [Bytes!]!
  "Link to all silo assets currently associated with this silo"
  assets: [SiloAsset!]! @derivedFrom(field: "silo")
  "Current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Deposited BDV from L1 which has not migrated yet"
  unmigratedL1DepositedBdv: BigInt
  "Current stalk balance"
  stalk: BigInt!
  "Current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  """
  Current grown stalk per season.
  NOTE: This value is currently not accurate for pre-gauge queries (BIP-45).
  A correct implementation would recalculate this value when a whitelisted token's seed amount is changed.
  """
  grownStalkPerSeason: BigInt!
  "Current roots balance"
  roots: BigInt!
  "[Seed Gauge] Stalk that is currently Germinating"
  germinatingStalk: BigInt!
  "[Seed Gauge] Current target ratio of Bean to LP deposits"
  beanToMaxLpGpPerBdvRatio: BigInt
  "Cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Current number of active farmers deposited in the silo"
  activeFarmers: Int!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [SiloHourlySnapshot!]! @derivedFrom(field: "silo")
  "Link to daily snapshot data"
  dailySnapshots: [SiloDailySnapshot!]! @derivedFrom(field: "silo")
}

type SiloHourlySnapshot @entity {
  "ID of silo - Season"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Silo associated with the snapshot"
  silo: Silo!
  "Point in time current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Point in time current stalk balance"
  stalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  "Point in time grown stalk per season"
  grownStalkPerSeason: BigInt!
  "Point in time current roots balance"
  roots: BigInt!
  "[Seed Gauge] Stalk that is currently Germinating"
  germinatingStalk: BigInt!
  "[Seed Gauge] Current target ratio of Bean to LP deposits"
  beanToMaxLpGpPerBdvRatio: BigInt
  "Point in time cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Point in time current number of active farmers deposited in the silo"
  activeFarmers: Int!

  deltaDepositedBDV: BigInt!
  deltaStalk: BigInt!
  deltaPlantableStalk: BigInt!
  deltaGrownStalkPerSeason: BigInt!
  deltaRoots: BigInt!
  deltaGerminatingStalk: BigInt!
  deltaBeanMints: BigInt!
  deltaActiveFarmers: Int!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!

  # caseId is unique to hourly snapshot
  "[Seed Gauge] The caseId used in the seasonal adjustment of beanToMaxLpGpPerBdvRatio"
  caseId: BigInt
}

type SiloDailySnapshot @entity {
  "ID of silo - Day"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Silo associated with the snapshot"
  silo: Silo!
  "Point in time current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Point in time current stalk balance"
  stalk: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  "Point in time grown stalk per season"
  grownStalkPerSeason: BigInt!
  "Point in time current roots balance"
  roots: BigInt!
  "[Seed Gauge] Stalk that is currently Germinating"
  germinatingStalk: BigInt!
  "[Seed Gauge] Current target ratio of Bean to LP deposits"
  beanToMaxLpGpPerBdvRatio: BigInt
  "Point in time cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Point in time current number of active farmers deposited in the silo"
  activeFarmers: Int!

  deltaDepositedBDV: BigInt!
  deltaStalk: BigInt!
  deltaPlantableStalk: BigInt!
  deltaGrownStalkPerSeason: BigInt!
  deltaRoots: BigInt!
  deltaGerminatingStalk: BigInt!
  deltaBeanMints: BigInt!
  deltaActiveFarmers: Int!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloAsset @entity {
  "Silo ID - Asset Token Address"
  id: ID!
  "Silo for this asset"
  silo: Silo!
  "Token address for this asset"
  token: Bytes!
  "Current Token amount of deposits"
  depositedAmount: BigInt!
  "Current BDV of deposits"
  depositedBDV: BigInt!
  "Current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!
  "Current internal (farm) balance of the asset"
  farmAmount: BigInt!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [SiloAssetHourlySnapshot!]! @derivedFrom(field: "siloAsset")
  "Link to daily snapshot data"
  dailySnapshots: [SiloAssetDailySnapshot!]! @derivedFrom(field: "siloAsset")
}

type SiloAssetHourlySnapshot @entity {
  "Silo Asset ID - Season"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Silo asset associated with this snapshot"
  siloAsset: SiloAsset!
  "Point in time current BDV of deposits"
  depositedBDV: BigInt!
  "Point in time current Token amount of deposits"
  depositedAmount: BigInt!
  "Point in time current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!
  "Point in time current internal (farm) balance of the asset"
  farmAmount: BigInt!

  deltaDepositedBDV: BigInt!
  deltaDepositedAmount: BigInt!
  deltaWithdrawnAmount: BigInt!
  deltaFarmAmount: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloAssetDailySnapshot @entity {
  "Silo Asset ID - Day"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Silo asset associated with this snapshot"
  siloAsset: SiloAsset!
  "Point in time current BDV of deposits"
  depositedBDV: BigInt!
  "Point in time current Token amount of deposits"
  depositedAmount: BigInt!
  "Point in time current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!
  "Point in time current internal (farm) balance of the asset"
  farmAmount: BigInt!

  deltaDepositedBDV: BigInt!
  deltaDepositedAmount: BigInt!
  deltaWithdrawnAmount: BigInt!
  deltaFarmAmount: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloYield @entity {
  "Season of data points - EMA window"
  id: ID!
  "Sortable int field for season"
  season: Int!
  "Window used for vAPY calc"
  emaWindow: EmaWindow!
  "Beta used for EMA"
  beta: BigDecimal!
  "u used for EMA"
  u: Int!
  "Bean EMA for season"
  beansPerSeasonEMA: BigDecimal!
  "Current whitelisted silo tokens"
  whitelistedTokens: [Bytes!]!
  "Current Bean (0) and Stalk (1) APY for each token."
  tokenAPYS: [TokenYield!]! @derivedFrom(field: "siloYield")
  "Unix timestamp of update"
  createdAt: BigInt!
}

type TokenYield @entity {
  "Token address - season - EMA window"
  id: Bytes!
  "Token being calculated"
  token: Bytes!
  "Season for APY calculation"
  season: Int!
  "Related silo yield entity"
  siloYield: SiloYield!
  "Bean APY for season"
  beanAPY: BigDecimal!
  "Stalk APY for season"
  stalkAPY: BigDecimal!
  "Unix timestamp of update"
  createdAt: BigInt!
}

type WhitelistTokenSetting @entity {
  "Contract address for the whitelisted token"
  id: Bytes!
  "Encoded BDV selector"
  selector: Bytes!
  "Represents how much Stalk one BDV of the underlying deposited token grows each season."
  stalkEarnedPerSeason: BigInt!
  "The stalk per BDV that the silo grants in exchange for depositing this token."
  stalkIssuedPerBdv: BigInt!
  "The last season in which the stalkEarnedPerSeason for this token was updated."
  milestoneSeason: Int!
  "Whether the seed gauge is enabled on this whitelisted token"
  isGaugeEnabled: Boolean!
  "[Seed Gauge] Current Gauge Points"
  gaugePoints: BigInt
  "[Seed Gauge] The current optimal targeted distribution of BDV for this whitelisted asset"
  optimalPercentDepositedBdv: BigInt
  "Last timestamp entity was updated"
  updatedAt: BigInt!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [WhitelistTokenHourlySnapshot!]! @derivedFrom(field: "token")
  "Link to daily snapshot data"
  dailySnapshots: [WhitelistTokenDailySnapshot!]! @derivedFrom(field: "token")

  # Unique to the main entity, not on dailySnapshots
  "Number of decimals in this token"
  decimals: Int!
}

type WhitelistTokenHourlySnapshot @entity {
  "Token address - Season"
  id: ID!
  "The season for this snapshot"
  season: Int!
  "WhitelistTokenSetting associated with this snapshot"
  token: WhitelistTokenSetting!
  "Encoded BDV selector"
  selector: Bytes!
  "Represents how much Stalk one BDV of the underlying deposited token grows each season."
  stalkEarnedPerSeason: BigInt!
  "The stalk per BDV that the silo grants in exchange for depositing this token."
  stalkIssuedPerBdv: BigInt!
  "The last season in which the stalkEarnedPerSeason for this token was updated."
  milestoneSeason: Int!
  "Whether the seed gauge is enabled on this whitelisted token"
  isGaugeEnabled: Boolean!
  "[Seed Gauge] Current Gauge Points"
  gaugePoints: BigInt
  "[Seed Gauge] The current optimal targeted distribution of BDV for this whitelisted asset"
  optimalPercentDepositedBdv: BigInt

  deltaStalkEarnedPerSeason: BigInt!
  deltaStalkIssuedPerBdv: BigInt!
  deltaMilestoneSeason: Int!
  deltaIsGaugeEnabled: Boolean!
  deltaGaugePoints: BigInt
  deltaOptimalPercentDepositedBdv: BigInt

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!

  # These are unique to the snapshot, and not on the main entity
  "Point in time hourly bdv"
  bdv: BigInt
  deltaBdv: BigInt
}

type WhitelistTokenDailySnapshot @entity {
  "Token address - Day"
  id: ID!
  "The season for this snapshot"
  season: Int!
  "WhitelistTokenSetting associated with this snapshot"
  token: WhitelistTokenSetting!
  "Encoded BDV selector"
  selector: Bytes!
  "Represents how much Stalk one BDV of the underlying deposited token grows each season."
  stalkEarnedPerSeason: BigInt!
  "The stalk per BDV that the silo grants in exchange for depositing this token."
  stalkIssuedPerBdv: BigInt!
  "The last season in which the stalkEarnedPerSeason for this token was updated."
  milestoneSeason: Int!
  "Whether the seed gauge is enabled on this whitelisted token"
  isGaugeEnabled: Boolean!
  "[Seed Gauge] Current Gauge Points"
  gaugePoints: BigInt
  "[Seed Gauge] The current optimal targeted distribution of BDV for this whitelisted asset"
  optimalPercentDepositedBdv: BigInt

  deltaStalkEarnedPerSeason: BigInt!
  deltaStalkIssuedPerBdv: BigInt!
  deltaMilestoneSeason: Int!
  deltaIsGaugeEnabled: Boolean!
  deltaGaugePoints: BigInt
  deltaOptimalPercentDepositedBdv: BigInt

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!

  # These are unique to the snapshot, and not on the main entity
  "Point in time daily bdv"
  bdv: BigInt
  deltaBdv: BigInt
}

type Field @entity {
  "Contract address for this field or farmer"
  id: Bytes!
  "'beanstalk'"
  beanstalk: Beanstalk!
  "Farmer address if applicable"
  farmer: Farmer
  "Current season number"
  season: Int!
  "Current temperature"
  temperature: Int!
  "Rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Cumulative number of unique sowers"
  numberOfSowers: Int!
  "Cumulative number of sows"
  numberOfSows: Int!
  "Cumulative total of sown beans"
  sownBeans: BigInt!
  "Array of current non-harvestable plots"
  plotIndexes: [BigInt!]!
  "Current outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Current harvestable pods"
  harvestablePods: BigInt!
  "Cumulative harvested pods"
  harvestedPods: BigInt!
  "Pods from L1 which has not been minted on L2 yet"
  unmigratedL1Pods: BigInt
  "Current amount of soil available"
  soil: BigInt!
  "Current pod index"
  podIndex: BigInt!
  "Current harvestable index"
  harvestableIndex: BigInt!
  "Current pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [FieldHourlySnapshot!]! @derivedFrom(field: "field")
  "Link to daily snapshot data"
  dailySnapshots: [FieldDailySnapshot!]! @derivedFrom(field: "field")
}

type FieldHourlySnapshot @entity {
  "Field ID - Season"
  id: ID!
  "Field associated with this snapshot"
  field: Field!
  "Season"
  season: Int!
  "Point in time temperature"
  temperature: Int!
  "Point in time rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Point in time cumulative number of unique sowers"
  numberOfSowers: Int!
  "Point in time cumulative number of sows"
  numberOfSows: Int!
  "Point in time cumulative total of sown beans"
  sownBeans: BigInt!
  "Point in time outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Point in time harvestable pods"
  harvestablePods: BigInt!
  "Point in time cumulative harvested pods"
  harvestedPods: BigInt!
  "Point in time amount of soil remaining"
  soil: BigInt!
  "Point in time amount of soil issued"
  issuedSoil: BigInt!
  "Point in time pod index"
  podIndex: BigInt!
  "Point in time harvestable index"
  harvestableIndex: BigInt!
  "Point in time pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!

  deltaTemperature: Int!
  deltaRealRateOfReturn: BigDecimal!
  deltaNumberOfSowers: Int!
  deltaNumberOfSows: Int!
  deltaSownBeans: BigInt!
  deltaUnharvestablePods: BigInt!
  deltaHarvestablePods: BigInt!
  deltaHarvestedPods: BigInt!
  deltaSoil: BigInt!
  deltaIssuedSoil: BigInt!
  deltaPodIndex: BigInt!
  deltaHarvestableIndex: BigInt!
  deltaPodRate: BigDecimal!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!

  # These are unique to hourly snapshot
  "The caseId used in the seasonal adjustment of temperature"
  caseId: BigInt
  "Block that started this season/at time of snapshot creation"
  seasonBlock: BigInt!
  "Number of blocks between sunrise and soil being sold out"
  blocksToSoldOutSoil: BigInt
  "Bool flag if soil sold out for the season"
  soilSoldOut: Boolean!
}

type FieldDailySnapshot @entity {
  "Field ID - Day"
  id: ID!
  "Field associated with this snapshot"
  field: Field!
  "Last season in the snapshot"
  season: Int!
  "Point in time temperature"
  temperature: Int!
  "Point in time rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Point in time cumulative number of unique sowers"
  numberOfSowers: Int!
  "Point in time cumulative number of sows"
  numberOfSows: Int!
  "Point in time cumulative total of sown beans"
  sownBeans: BigInt!
  "Point in time outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Point in time harvestable pods"
  harvestablePods: BigInt!
  "Point in time delta harvested pods"
  harvestedPods: BigInt!
  "Point in time amount of soil remaining"
  soil: BigInt!
  "Point in time amount of soil issued"
  issuedSoil: BigInt!
  "Point in time pod index"
  podIndex: BigInt!
  "Point in time harvestable index"
  harvestableIndex: BigInt!
  "Point in time pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!

  deltaTemperature: Int!
  deltaRealRateOfReturn: BigDecimal!
  deltaNumberOfSowers: Int!
  deltaNumberOfSows: Int!
  deltaSownBeans: BigInt!
  deltaUnharvestablePods: BigInt!
  deltaHarvestablePods: BigInt!
  deltaHarvestedPods: BigInt!
  deltaSoil: BigInt!
  deltaIssuedSoil: BigInt!
  deltaPodIndex: BigInt!
  deltaHarvestableIndex: BigInt!
  deltaPodRate: BigDecimal!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

# ---===== Farmer Account Entities =====---

type Farmer @entity {
  "Address for the farmer"
  id: Bytes!
  silo: Silo @derivedFrom(field: "farmer")
  deposits: [SiloDeposit!]! @derivedFrom(field: "farmer")
  withdraws: [SiloWithdraw!]! @derivedFrom(field: "farmer")
  field: Field @derivedFrom(field: "farmer")
  plots: [Plot!]! @derivedFrom(field: "farmer")
  listings: [PodListing!]! @derivedFrom(field: "farmer")
  orders: [PodOrder!]! @derivedFrom(field: "farmer")
  fills: [PodFill!]! @derivedFrom(field: "toFarmer")
  fertilizers: [FertilizerBalance!]! @derivedFrom(field: "farmer")
}

type SiloDeposit @entity {
  """
  Account - Token Address - Deposit Version - (Season|Stem)
  """
  id: ID!
  "Farmer address"
  farmer: Farmer!
  "Token Address"
  token: Bytes!
  "Version of deposit. Options are season, v3, v3.1. `season` type includes those deposits which are calculated according to their silo v1 deposits pre-explout"
  depositVersion: String!
  "Season of deposit"
  season: Int
  "Stem of deposit"
  stem: BigInt
  "Silo v3.1 equivalent stem. This value will always be assigned regardless of the deposit version."
  stemV31: BigInt!
  "Token amount deposited"
  depositedAmount: BigInt!
  "Original deposited BDV"
  depositedBDV: BigInt!
  "Transaction hashes pertaining to this deposit"
  hashes: [Bytes!]!
  "Block of first deposit"
  createdBlock: BigInt!
  "Block when last updated"
  updatedBlock: BigInt!
  "Timestamp of first deposit"
  createdAt: BigInt!
  "Timestamp when last updated"
  updatedAt: BigInt!
}

type SiloWithdraw @entity {
  "Account - Deposit Token - Current Season"
  id: ID!
  "Farmer address"
  farmer: Farmer!
  "Token address"
  token: Bytes!
  "Season withdrawal initiated"
  withdrawSeason: Int!
  "Season when withdrawal can be claimed"
  claimableSeason: Int!
  "Flag for if this has been claimed"
  claimed: Boolean!
  "Token amount withdrawn"
  amount: BigInt!
  "Timestamp created"
  createdAt: BigInt!
}

type Plot @entity {
  "Plot index"
  id: ID!
  "Field to which this plot belongs"
  field: Field!
  "Farmer who owns this plot"
  farmer: Farmer!
  "Transaction source for this plot. Not the same as creationHash which can include plots splitting from transfer or harvest without the owner changing"
  source: PlotSource!
  "Transaction hash corresponding to source"
  sourceHash: Bytes!
  "Associated plot listing"
  listing: PodListing
  "Season when created"
  season: Int!
  "Transaction hash of when this plot entity was created"
  creationHash: Bytes!
  "Timestamp of creation"
  createdAt: BigInt!
  "Timestamp when updated"
  updatedAt: BigInt!
  "Block when updated"
  updatedAtBlock: BigInt!
  "Plot Index"
  index: BigInt!
  "Total pods in plot"
  pods: BigInt!
  "Number of beans spent for each pod, whether through sowing or on the marketplace"
  beansPerPod: BigInt!
  "Number of pods harvestable"
  harvestablePods: BigInt!
  "Number of pods harvested"
  harvestedPods: BigInt!
  "Flag for if plot is fully harvested"
  fullyHarvested: Boolean!
}

type PodMarketplace @entity {
  "Field id"
  id: ID!
  "Current season of the marketplace"
  season: Int!
  "Information about the active pod listings. Each entry of the form 'account-index-expiry'"
  activeListings: [String!]!
  "Information about the active pod orders. Each entry of the form 'orderId-maxPlaceInLine'"
  activeOrders: [String!]!
  "All historical listings"
  allListings: [PodListing!]! @derivedFrom(field: "podMarketplace")
  "All historical orders"
  allOrders: [PodOrder!]! @derivedFrom(field: "podMarketplace")
  "All historical marketplace fills"
  fills: [PodFill!]! @derivedFrom(field: "podMarketplace")
  "Current cumulative pods listed for sale"
  listedPods: BigInt!
  "Current amount of total pods listed"
  availableListedPods: BigInt!
  "Current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Current cumulative beans in pod orders created"
  orderBeans: BigInt!
  "Current amount of total beans in pod orders"
  availableOrderBeans: BigInt!
  "Current cumulative filled beans in pod orders"
  filledOrderBeans: BigInt!
  "Current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Current cumulative beans in pod orders cancelled"
  cancelledOrderBeans: BigInt!
  "Cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Cumulative bean volume between listings and orders"
  beanVolume: BigInt!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [PodMarketplaceHourlySnapshot!]! @derivedFrom(field: "podMarketplace")
  "Link to daily snapshot data"
  dailySnapshots: [PodMarketplaceDailySnapshot!]! @derivedFrom(field: "podMarketplace")
}

type PodMarketplaceHourlySnapshot @entity {
  "Marketplace ID - Season"
  id: ID!
  "Point in time latest season"
  season: Int!
  "Marketplace associated with snapshot"
  podMarketplace: PodMarketplace!
  "Point in time current cumulative pods listed for sale"
  listedPods: BigInt!
  "Point in time current amount of total pods listed"
  availableListedPods: BigInt!
  "Point in time current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Point in time current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Point in time current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Current cumulative beans in pod orders created"
  orderBeans: BigInt!
  "Current amount of total beans in pod orders"
  availableOrderBeans: BigInt!
  "Current cumulative filled beans in pod orders"
  filledOrderBeans: BigInt!
  "Current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Current cumulative beans in pod orders cancelled"
  cancelledOrderBeans: BigInt!
  "Point in time current cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Point in time current cumulative bean volume between listings and orders"
  beanVolume: BigInt!

  deltaListedPods: BigInt!
  deltaAvailableListedPods: BigInt!
  deltaFilledListedPods: BigInt!
  deltaExpiredListedPods: BigInt!
  deltaCancelledListedPods: BigInt!
  deltaOrderBeans: BigInt!
  deltaAvailableOrderBeans: BigInt!
  deltaFilledOrderBeans: BigInt!
  deltaFilledOrderedPods: BigInt!
  deltaCancelledOrderBeans: BigInt!
  deltaPodVolume: BigInt!
  deltaBeanVolume: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type PodMarketplaceDailySnapshot @entity {
  "Marketplace ID - Day"
  id: ID!
  "Point in time latest season"
  season: Int!
  "Marketplace associated with snapshot"
  podMarketplace: PodMarketplace!
  "Point in time current cumulative pods listed for sale"
  listedPods: BigInt!
  "Point in time current amount of total pods listed"
  availableListedPods: BigInt!
  "Point in time current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Point in time current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Point in time current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Current cumulative beans in pod orders created"
  orderBeans: BigInt!
  "Current amount of total beans in pod orders"
  availableOrderBeans: BigInt!
  "Current cumulative filled beans in pod orders"
  filledOrderBeans: BigInt!
  "Current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Current cumulative beans in pod orders cancelled"
  cancelledOrderBeans: BigInt!
  "Point in time current cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Point in time current cumulative bean volume between listings and orders"
  beanVolume: BigInt!

  deltaListedPods: BigInt!
  deltaAvailableListedPods: BigInt!
  deltaFilledListedPods: BigInt!
  deltaExpiredListedPods: BigInt!
  deltaCancelledListedPods: BigInt!
  deltaOrderBeans: BigInt!
  deltaAvailableOrderBeans: BigInt!
  deltaFilledOrderBeans: BigInt!
  deltaFilledOrderedPods: BigInt!
  deltaCancelledOrderBeans: BigInt!
  deltaPodVolume: BigInt!
  deltaBeanVolume: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type PodListing @entity {
  ######################## Identifiers ########################

  """
  The PodListing ID is a unique subgraph ID: `{account}-{index}"

  The on-chain identifier for a PodListing is the `index`.
  """
  id: ID!

  "Marketplace used for listing"
  podMarketplace: PodMarketplace!

  "Historical ID for joins"
  historyID: String!

  "Plot being Listed."
  plot: Plot!

  "The Farmer that created the PodListing."
  farmer: Farmer!

  ######################## Configuration ########################

  """
  The absolute index of the listed Plot in the Pod Line.

  Measured from the front, so the Listing contains all Pods between
  (index) and (index + totalAmount).

  An example where the podLine is 50,000 but the index is 150,000:
     0         the first Pod issued
     100,000   harvestableIndex
     150,000   index
  """
  index: BigInt!

  """
  The position within the Plot from which to sell Pods.

  0 <= `start` <= (plot size - `amount`)
  """
  start: BigInt!

  "Where Beans are sent when the PodListing is Filled. See `FarmToMode`."
  mode: Int!

  ######################## Constraints ########################

  """
  When the `harvestableIndex` reaches this number, the Listing becomes EXPIRED.
  """
  maxHarvestableIndex: BigInt!

  "Minimum number of Beans required to perform a Fill."
  minFillAmount: BigInt!

  ######################## Pricing ########################

  """
  The Pricing Type states whether this PodListing uses FIXED or DYNAMIC pricing.

  null = V1 FIXED  = use `pricePerPod`
  0    = V2 FIXED  = use `pricePerPod`
  1    = V2 DYNAMIC = use `pricingFunction`
  """
  pricingType: Int

  """
  [V1] The FIXED price per Pod denominated in Beans.

  Ex. `pricePerPod = 10000` indicates a price of 0.01 Beans per Pod.

  If `pricingType = 1`, this field is set to `0` and should be ignored.
  """
  pricePerPod: Int!

  """
  [V2] The FIXED or DYNAMIC pricing function, encoded as bytes.

  This must be decoded client-side, see `LibPolynomial.sol` for more info.
  """
  pricingFunction: Bytes

  ######################## Amounts [Relative to Original] ########################

  """
  The original index from the first emission of PodListingCreated in a chain.

  If `originalIndex !== index`, then this PodListing was created when a parent
  PodListing was partially filled.
  """
  originalIndex: BigInt!

  """
  The total number of Pods listed during the first emission of PodListingCreated.
  """
  originalAmount: BigInt!

  """
  The amount of Pods Filled since the initial PodListing was Created.

  `0 <= filled <= originalAmount`
  """
  filled: BigInt!

  ######################## Amounts [Relative to Child] ########################

  """
  The maximum amount of Pods remaining to be sold by *this* PodListing.

  When this PodListing is Filled or Cancelled, `amount` does NOT change.
  """
  amount: BigInt!

  """
  The number of Pods remaining in *this* PodListing.

  When a Fill occurs, `remainingAmount` is decremented on this PodListing. A new
  PodListing is created with an updated `index` and `amount` equal to this
  PodListing's remainingAmount.

  If this PodListing has NOT been Filled: `remainingAmount = amount`
  If this PodListing has been Filled: `remainingAmount < amount`
  If this PodListing has been Cancelled: `remainingAmount = 0`
  """
  remainingAmount: BigInt!

  """
  The number of Pods purchased from *this* PodListing.

  If not yet Filled or the PodListing is CANCELLED: `filledAmount = 0`
  """
  filledAmount: BigInt!

  ######################## Activity ########################

  "Any Fills associated with this PodListing."
  fill: PodFill

  ######################## Metadata ########################

  "Current market status of listing"
  status: MarketStatus!

  "Timestamp of PodListing creation."
  createdAt: BigInt!

  "Timestamp of last update to this PodListing, including Fills and Cancellations."
  updatedAt: BigInt!

  "Transaction hash when this PodListing entity was created."
  creationHash: Bytes!
}

type PodOrder @entity {
  ######################## Identifiers ########################

  """
  The PodOrder ID matchces the `id` stored on-chain:

  `keccak256(abi.encodePacked(account, pricePerPod, maxPlaceInLine, minFillAmount))`
  """
  id: ID!

  """
  Historical ID for joins: `{account}-{createdAt}`
  """
  historyID: String!

  "The Farmer that created the Pod Order."
  farmer: Farmer!

  "Marketplace used for Pod Order."
  podMarketplace: PodMarketplace!

  ######################## Constraints ########################

  """
  The Farmer is willing to buy any Pod that is before maxPlaceInLine at pricePerPod.
  As the Pod Line moves, this value stays the same because new Pods meet the criteria.
  """
  maxPlaceInLine: BigInt!

  "Minimum number of Pods required to perform a Fill."
  minFillAmount: BigInt!

  ######################## Pricing ########################

  """
  The Pricing Type states whether this PodOrder uses FIXED or DYNAMIC pricing.

  null = V1 FIXED  = use `pricePerPod`
  0    = V2 FIXED  = use `pricePerPod`
  1    = V2 DYNAMIC = use `pricingFunction`
  """
  pricingType: Int

  """
  [V1] The FIXED price per Pod denominated in Beans.

  Ex. `pricePerPod = 10000` indicates a price of 0.01 Beans per Pod.

  If `pricingType = 1`, this field is initialized to `0` and should be ignored.
  """
  pricePerPod: Int!

  """
  [V2] The FIXED or DYNAMIC pricing function, encoded as bytes.

  This must be decoded client-side, see `LibPolynomial.sol` for more info.

  null    = V1 FIXED    = use `pricePerPod`
  "0x"    = V2 FIXED    = use `pricePerPod`
  "0x..." = V2 DYNAMIC  = use `pricingFunction`
  """
  pricingFunction: Bytes

  ######################## Amounts ########################

  """
  The original number of Beans locked in the PodOrder.

  Does NOT change as Fills occur.
  Always deterministic, since the Farmer must lock Beans for PodOrder fulfillment.

  If FIXED (V1): `amount * pricePerPod` fields emitted in PodOrderCreated.
  If FIXED (V2): `amount` field emitted in PodOrderCreated.
  If DYNAMIC (V2): `amount` field emitted in PodOrderCreated.
  """
  beanAmount: BigInt!

  """
  The current number of Pods that have been purchased by this PodOrder.

  Increases during each subsequent Fill.
  If pricingType = FIXED: `0 <= podAmountFilled <= podAmount`
  If pricingType = DYNAMIC: No constraint, since `podAmount` is unknown.

  Upon PodOrder cancellation, this value is locked.
  """
  podAmountFilled: BigInt!

  """
  The current number of Beans spent to acquire Pods.

  Increases during each subsequent Fill:
  `0 <= beanAmountFilled <= beanAmount`

  Upon PodOrder cancellation, this value is locked.
  """
  beanAmountFilled: BigInt!

  ######################## Activity ########################

  "All Fills associated with this PodOrder."
  fills: [PodFill!]!

  ######################## Metadata ########################

  "Current status of order."
  status: MarketStatus!

  "Timestamp of PodOrder creation."
  createdAt: BigInt!

  "Timestamp of last PodOrder update. Changes when a PodOrder is Filled or Cancelled."
  updatedAt: BigInt!

  "Transaction hash when this PodOrder entity was created."
  creationHash: Bytes!
}

type PodFill @entity {
  "Beanstalk address - Order/Listing index - transaction hash"
  id: ID!
  "Marketplace associated with this fill"
  podMarketplace: PodMarketplace!
  "Creation timestamp"
  createdAt: BigInt!
  "Associated listing, if any"
  listing: PodListing
  "Associated order, if any"
  order: PodOrder
  "Account that is sending pods"
  fromFarmer: Bytes! # These are already referenced via the listing and order entities.
  "Account that is receiving pods"
  toFarmer: Farmer!
  "Number of pods filled"
  amount: BigInt!
  "Where these pods were in line when filled"
  placeInLine: BigInt!
  "Index of plot transferred"
  index: BigInt!
  "Start of plot transferred"
  start: BigInt!
  "Total beans used to fill listing/order"
  costInBeans: BigInt!
}

##################################
##### Fertilizer Entities #####
##################################

# Global Fertilizer state for tracking
type Fertilizer @entity {
  "Token address for fert"
  id: Bytes!
  "'beanstalk'"
  beanstalk: String!
  "Total overall suppy of fert tokens"
  supply: BigInt!
  "Supply from L1 which has not been minted on L2 yet"
  unmigratedL1Supply: BigInt
  tokens: [FertilizerToken!]! @derivedFrom(field: "fertilizer")
}

# Id-level Fertilizer entity
type FertilizerToken @entity {
  "Total BPF for purchase"
  id: ID!
  fertilizer: Fertilizer!
  "Total supply for this Humidity"
  supply: BigInt!
  "Humidity paid for this ID"
  humidity: BigDecimal!
  "Ending BPF on creation"
  endBpf: BigInt!
  "Starting BPF on creation"
  startBpf: BigInt!
  "Season created"
  season: Int!
  balances: [FertilizerBalance!]! @derivedFrom(field: "fertilizerToken")
}

type FertilizerBalance @entity {
  "Fertilizer Token - Farmer address"
  id: ID!
  fertilizerToken: FertilizerToken!
  farmer: Farmer!
  "Current balance of token"
  amount: BigInt!
}

type FertilizerYield @entity {
  "Season of data points"
  id: ID!
  "Current season"
  season: Int!
  "Bean EMA Window"
  emaWindow: EmaWindow!
  "Current humidity"
  humidity: BigDecimal!
  "Current outstanding fert"
  outstandingFert: BigInt!
  "Current Bean EMA"
  beansPerSeasonEMA: BigDecimal!
  "BPF delta"
  deltaBpf: BigDecimal!
  "Simplified APY for new Fert"
  simpleAPY: BigDecimal!
  "Block timestamp at creation"
  createdAt: BigInt!
}

##################################
##### Event-Level Data #####
##################################

interface MarketplaceEvent {
  "{ Event type }-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type Chop @entity(immutable: true) {
  "(chop|convert)-{ Transaction hash }-{ Log index }"
  id: ID!
  "Account address"
  farmer: Farmer!
  "The unripe token which was chopped"
  unripeToken: UnripeToken!
  "Unripe token amount which was chopped"
  unripeAmount: BigInt!
  "Bdv of the unripe tokens which were chopped"
  unripeBdv: BigInt!
  "The underlying ERC20 token received by `farmer` as a result of this chop"
  underlyingToken: WhitelistTokenSetting!
  "Amount of underlying tokens `farmer` received"
  underlyingAmount: BigInt!
  "Amount of bdv `farmer` received"
  underlyingBdv: BigInt!
  "The effective chop rate for this chop"
  chopRate: BigDecimal!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "The block number of this event"
  blockNumber: BigInt!
  "Timestamp of this chop"
  createdAt: BigInt!
}

type PodListingCreated implements MarketplaceEvent @entity(immutable: true) {
  "podListingCreated-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account creating the listing"
  account: Bytes!
  "Where these pods were in line when listed"
  placeInLine: BigInt!
  "Index of the plot listed"
  index: BigInt!
  "Start value of the plot listed"
  start: BigInt!
  "Amount of pods listed"
  amount: BigInt!
  "Price per pod"
  pricePerPod: Int!
  "Max index for listing"
  maxHarvestableIndex: BigInt!
  "Minimum fill amount"
  minFillAmount: BigInt!
  "Claim to location"
  mode: Int!
  "Pricing Function Data"
  pricingFunction: Bytes
  "Pricing Type"
  pricingType: Int
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodListingFilled implements MarketplaceEvent @entity(immutable: true) {
  "podListingFilled-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account selling pods"
  fromFarmer: Bytes!
  "Account buying pods"
  toFarmer: Bytes!
  "Where these pods were in line when filled"
  placeInLine: BigInt!
  "Index of the plot transferred"
  index: BigInt!
  "Start of the plot transferred"
  start: BigInt!
  "Number of pods transferred"
  amount: BigInt!
  "Beans paid to fill the listing"
  costInBeans: BigInt
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodListingCancelled implements MarketplaceEvent @entity(immutable: true) {
  "seedChange-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account cancelling listing"
  account: Bytes!
  "Where these pods were in line when cancelled"
  placeInLine: BigInt!
  "Index of plot listing being cancelled"
  index: BigInt!
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodOrderCreated implements MarketplaceEvent @entity(immutable: true) {
  "podOrderCreated-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account creating the listing"
  account: Bytes!
  "ID of the pod order"
  orderId: String!
  """
  The represented value emitted with this event changed with BIP-29 at block 15277986
  Pre  BIP-29: The number of pods ordered is emitted
  Post BIP-29: The number of beans supplied for the order is emitted.
  """
  amount: BigInt!
  "Price per pod"
  pricePerPod: Int!
  "Max place in line"
  maxPlaceInLine: BigInt!
  "Pricing Function Data"
  pricingFunction: Bytes
  "Pricing Type"
  pricingType: Int
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodOrderFilled implements MarketplaceEvent @entity(immutable: true) {
  "podOrderFilled-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account selling pods"
  fromFarmer: Bytes!
  "Account buying pods"
  toFarmer: Bytes!
  "Where these pods were in line when filled"
  placeInLine: BigInt!
  "Index of the plot transferred"
  index: BigInt!
  "Start of the plot transferred"
  start: BigInt!
  "Number of pods transferred"
  amount: BigInt!
  "Beans paid to fill the order"
  costInBeans: BigInt
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodOrderCancelled implements MarketplaceEvent @entity(immutable: true) {
  "podOrderCancelled-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account cancelling listing"
  account: Bytes!
  "ID of order cancelled"
  orderId: String!
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

# For each applicable address there will be a max of two germinating entities - one even and one odd
type Germinating @entity {
  "Address-(EVEN|ODD)"
  id: ID!
  "Address of the token or account which is germinating"
  address: Bytes!
  "EVEN or ODD"
  type: String!
  "True when the address is a farmer account"
  isFarmer: Boolean!
  "The season in which the germination started"
  season: Int!
  "Germinating stalk. This only applies to farmer/protocol address"
  stalk: BigInt!
  "Germinating tokens. This only applies to a Token address"
  tokenAmount: BigInt!
  "Germinating bdv. This only applies to a Token address"
  bdv: BigInt!
}

# This entity exists solely for resolving the issue in LibGerminate when deposits from multiple seasons
# complete their germination (the event emission itself has a bug)
type PrevFarmerGerminatingEvent @entity {
  "Farmer address"
  id: Bytes!
  "The `block.number` of the `FarmerGerminatingStalkBalanceChanged` event"
  eventBlock: BigInt!
  "The `logIndex` of the `FarmerGerminatingStalkBalanceChanged` event"
  logIndex: BigInt!
  "The value for `deltaGerminatingStalk` from this previous `FarmerGerminatingStalkBalanceChanged` event."
  deltaGerminatingStalk: BigInt!
}

type UnripeToken @entity {
  "Token Address"
  id: Bytes!
  "The ripe token underlying this unripe asset"
  underlyingToken: WhitelistTokenSetting!
  "The total amount of `underlyingToken` for this unripe token (getTotalUnderlying)"
  totalUnderlying: BigInt!
  "The amount of `underlyingToken` corresponding to one of this unripe token (getUnderlyingPerUnripeToken)"
  amountUnderlyingOne: BigInt!
  "The bdv of `amountUnderlyingOne` of `underlyingToken`. Assumed to not always be the same as bdv(id)"
  bdvUnderlyingOne: BigInt!
  "The amount of `underlyingToken` which would be received if one of this unripe token were to be chopped (getPenalty)"
  choppableAmountOne: BigInt!
  "The bdv that would be received if one of this unripe token were to be chopped"
  choppableBdvOne: BigInt!
  "The chop rate, in percent (getPercentPenalty)"
  chopRate: BigDecimal!
  "The amount recapitalized, in percent (getRecapFundedPercent)"
  recapPercent: BigDecimal!
  "The total amount of this unripe token which has been chopped"
  totalChoppedAmount: BigInt!
  "The total bdv of this unripe token which has been chopped"
  totalChoppedBdv: BigInt!
  "The total bdv of all `underlyingToken` that has been received from chopping"
  totalChoppedBdvReceived: BigInt!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [UnripeTokenHourlySnapshot!]! @derivedFrom(field: "unripeToken")
  "Link to daily snapshot data"
  dailySnapshots: [UnripeTokenDailySnapshot!]! @derivedFrom(field: "unripeToken")
}

type UnripeTokenHourlySnapshot @entity {
  "UnripeToken ID - Season"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Unripe token associated with this snapshot"
  unripeToken: UnripeToken!

  "Point in time ripe token underlying this unripe asset"
  underlyingToken: WhitelistTokenSetting!
  "Point in time total amount of `underlyingToken` for this unripe token (getTotalUnderlying)"
  totalUnderlying: BigInt!
  "Point in time amount of `underlyingToken` corresponding to one of this unripe token (getUnderlyingPerUnripeToken)"
  amountUnderlyingOne: BigInt!
  "Point in time bdv of `amountUnderlyingOne` of `underlyingToken`. Assumed to not always be the same as bdv(id)"
  bdvUnderlyingOne: BigInt!
  "Point in time amount of `underlyingToken` which would be received if one of this unripe token were to be chopped (getPenalty)"
  choppableAmountOne: BigInt!
  "Point in time bdv that would be received if one of this unripe token were to be chopped"
  choppableBdvOne: BigInt!
  "Point in time chop rate, in percent (getPercentPenalty)"
  chopRate: BigDecimal!
  "Point in time amount recapitalized, in percent (getRecapFundedPercent)"
  recapPercent: BigDecimal!
  "Point in time total amount of this unripe token which has been chopped"
  totalChoppedAmount: BigInt!
  "Point in time total bdv of this unripe token which has been chopped"
  totalChoppedBdv: BigInt!
  "Point in time total bdv of all `underlyingToken` that has been received from chopping"
  totalChoppedBdvReceived: BigInt!

  deltaUnderlyingToken: Boolean!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaTotalUnderlying: BigInt!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaAmountUnderlyingOne: BigInt!
  deltaBdvUnderlyingOne: BigInt!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaChoppableAmountOne: BigInt!
  deltaChoppableBdvOne: BigInt!
  deltaChopRate: BigDecimal!
  deltaRecapPercent: BigDecimal!
  deltaTotalChoppedAmount: BigInt!
  deltaTotalChoppedBdv: BigInt!
  deltaTotalChoppedBdvReceived: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type UnripeTokenDailySnapshot @entity {
  "UnripeToken ID - Day"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Unripe token associated with this snapshot"
  unripeToken: UnripeToken!

  "Point in time ripe token underlying this unripe asset"
  underlyingToken: WhitelistTokenSetting!
  "Point in time total amount of `underlyingToken` for this unripe token (getTotalUnderlying)"
  totalUnderlying: BigInt!
  "Point in time amount of `underlyingToken` corresponding to one of this unripe token (getUnderlyingPerUnripeToken)"
  amountUnderlyingOne: BigInt!
  "Point in time bdv of `amountUnderlyingOne` of `underlyingToken`. Assumed to not always be the same as bdv(id)"
  bdvUnderlyingOne: BigInt!
  "Point in time amount of `underlyingToken` which would be received if one of this unripe token were to be chopped (getPenalty)"
  choppableAmountOne: BigInt!
  "Point in time bdv that would be received if one of this unripe token were to be chopped"
  choppableBdvOne: BigInt!
  "Point in time chop rate, in percent (getPercentPenalty)"
  chopRate: BigDecimal!
  "Point in time amount recapitalized, in percent (getRecapFundedPercent)"
  recapPercent: BigDecimal!
  "Point in time total amount of this unripe token which has been chopped"
  totalChoppedAmount: BigInt!
  "Point in time total bdv of this unripe token which has been chopped"
  totalChoppedBdv: BigInt!
  "Point in time total bdv of all `underlyingToken` that has been received from chopping"
  totalChoppedBdvReceived: BigInt!

  deltaUnderlyingToken: Boolean!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaTotalUnderlying: BigInt!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaAmountUnderlyingOne: BigInt!
  deltaBdvUnderlyingOne: BigInt!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaChoppableAmountOne: BigInt!
  deltaChoppableBdvOne: BigInt!
  deltaChopRate: BigDecimal!
  deltaRecapPercent: BigDecimal!
  deltaTotalChoppedAmount: BigInt!
  deltaTotalChoppedBdv: BigInt!
  deltaTotalChoppedBdvReceived: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}
