import { Source } from "graphql";
import { sum } from "lodash";
import { Token } from "src/classes/Token";
import { TokenValue } from "src/TokenValue";
import { getTestUtils } from "src/utils/TestUtils/provider";
import { DataSource } from "../BeanstalkSDK";
import { Convert } from "./Convert";

const { sdk, account, utils } = getTestUtils();

jest.setTimeout(30000);

describe("Silo Convert", function () {
  const convert = new Convert(sdk);
  const BEAN = sdk.tokens.BEAN;
  const BEANLP = sdk.tokens.BEAN_CRV3_LP;
  const urBEAN = sdk.tokens.UNRIPE_BEAN;
  const urBEANLP = sdk.tokens.UNRIPE_BEAN_WETH;
  const whitelistedTokens = [BEAN, BEANLP, urBEAN, urBEANLP];

  beforeAll(async () => {
    await utils.resetFork();
    // set default state as p > 1
    await utils.setCurveLiquidity(10_000_000, 15_000_000);
  });

  it("Validates tokens", async () => {
    const a = async () => {
      await convert.convert(sdk.tokens.USDC, BEANLP, TokenValue.ONE);
      throw new Error("fromToken is nost whitelisted");
    };
    const b = async () => {
      await convert.convert(BEAN, sdk.tokens.USDC, TokenValue.ONE);
      throw new Error("fromToken is nost whitelisted");
    };
    const c = async () => {
      await convert.convert(BEAN, BEAN, TokenValue.ONE);
      throw new Error("Cannot convert between the same token");
    };
    await expect(a).rejects.toThrowError("fromToken is not whitelisted");
    await expect(b).rejects.toThrowError("toToken is not whitelisted");
    await expect(c).rejects.toThrowError("Cannot convert between the same token");
  });

  it("Validates amount", async () => {
    await utils.setBEANBalance(account, TokenValue.ZERO);
    const a = async () => {
      await convert.convert(BEAN, BEANLP, BEAN.amount(500));
    };

    await expect(a).rejects.toThrowError("Insufficient balance");
  });

  it("Calculates crates when toToken is LP", async () => {
    const currentSeason = 10_000;
    const c1 = utils.mockDepositCrate(BEAN, 9000, "500", currentSeason);
    const c2 = utils.mockDepositCrate(BEAN, 9001, "300", currentSeason);
    const c3 = utils.mockDepositCrate(BEAN, 9002, "100", currentSeason);

    // random order
    const crates = [c3, c1, c2];

    // ensure it picks across multiple crates
    // crates should be sorted ASC by season
    const calc1 = convert.calculateConvert(BEAN, BEANLP, BEAN.amount(850), crates, currentSeason);
    expect(calc1.crates.length).toEqual(3);
    expect(calc1.crates[0].amount.toHuman()).toEqual("500"); // takes full amount from c1
    expect(calc1.crates[0].stem.toString()).toEqual("9000"); // confirm this is c1
    expect(calc1.crates[1].amount.toHuman()).toEqual("300"); // takes full amount from c2
    expect(calc1.crates[1].stem.toString()).toEqual("9001"); // confirm this is c2
    expect(calc1.crates[2].amount.toHuman()).toEqual("50"); // takes 300 from c3
    expect(calc1.crates[2].stem.toString()).toEqual("9002"); // confirm this is c3
    expect(calc1.seeds.toHuman()).toEqual("1700");
    expect(calc1.stalk.toHuman()).toEqual("1019.92");

    // ensure it pulls one crate
    // crate should be sorted ASC by season
    const calc2 = convert.calculateConvert(BEAN, BEANLP, BEAN.amount(400), crates, currentSeason);
    expect(calc2.crates.length).toEqual(1);
    expect(calc2.crates[0].amount.toHuman()).toEqual("400"); // takes full amount from c1
    expect(calc1.crates[0].stem.toString()).toEqual("9000"); // confirm this is c3
    expect(calc2.seeds.toHuman()).toEqual("800");
    expect(calc2.stalk.toHuman()).toEqual("480");
  });

  it("Calculates crates when toToken is NOT LP", async () => {
    const currentSeason = 10393;
    // the bdv generated by the mock is exactly the same as the amount
    // but we need them to be slightly different for sorting to be noticeable
    const c1 = utils.mockDepositCrate(BEANLP, 10100, "2000", currentSeason);
    c1.bdv = TokenValue.fromHuman(2123, 6);
    // ratio: 2123/2000 = 1.0615

    const c2 = utils.mockDepositCrate(BEANLP, 10101, "1000", currentSeason);
    c2.bdv = TokenValue.fromHuman(1234, 6);
    // ratio: 1234/1000 = 1.234

    const c3 = utils.mockDepositCrate(BEANLP, 10102, "500", currentSeason);
    c3.bdv = TokenValue.fromHuman(534, 6);
    // ratio: 534/500 = 1.068

    // random order
    const crates = [c2, c1, c3];

    // ensure it picks across multiple crates
    // crates should be sorted ASC by BDVRatio
    const calc1 = convert.calculateConvert(BEANLP, BEAN, BEANLP.amount(3000), crates, currentSeason);

    expect(calc1.crates.length).toEqual(3);
    expect(calc1.crates[0].amount.toHuman()).toEqual("2000"); // takes full amount from c1
    expect(calc1.crates[0].stem.toString()).toEqual("10100"); // confirm this is c1
    expect(calc1.crates[1].amount.toHuman()).toEqual("500"); // takes full amount from c2
    expect(calc1.crates[1].stem.toString()).toEqual("10102"); // confirm this is c2
    expect(calc1.crates[2].amount.toHuman()).toEqual("500"); // takes 300 from c3
    expect(calc1.crates[2].stem.toString()).toEqual("10101"); // confirm this is c3
    expect(calc1.seeds.toHuman()).toEqual("13096");
    expect(calc1.stalk.toHuman()).toEqual("3625");

    // ensure it pulls one crate
    // crate should be sorted ASC by season
    const calc2 = convert.calculateConvert(BEAN, BEANLP, BEAN.amount(2000), crates, currentSeason);
    expect(calc2.crates.length).toEqual(1);
    expect(calc2.crates[0].amount.toHuman()).toEqual("2000"); // takes full amount from c1
    expect(calc1.crates[0].stem.toString()).toEqual("10100"); // confirm this is c3
    expect(calc2.seeds.toHuman()).toEqual("4246");
    expect(calc2.stalk.toHuman()).toEqual("2357.4");
  });

  describe.each([
    { from: BEAN, to: BEAN },
    { from: BEANLP, to: BEANLP },
    { from: urBEAN, to: urBEAN },
    { from: urBEANLP, to: urBEANLP }
  ])("Convert to self fails", (pair) => {
    const { from, to } = pair;

    it(`Convert ${from.symbol} -> ${to.symbol}`, async () => {
      const fn = async () => sdk.silo.convert(from, to, from.amount(1));
      await expect(fn).rejects.toThrowError("Cannot convert between the same token");
    });
  });

  describe("With balance", () => {
    beforeAll(async () => {
      await deposit(BEAN, BEAN, 500);
      await deposit(BEANLP, BEANLP, 500);
      await deposit(urBEAN, urBEAN, 500);
      await deposit(urBEANLP, urBEANLP, 500);
    });

    describe.each([
      { from: BEAN, to: urBEAN },
      { from: BEAN, to: urBEANLP },

      { from: BEANLP, to: urBEAN },
      { from: BEANLP, to: urBEANLP },

      { from: urBEAN, to: BEAN },
      { from: urBEAN, to: BEANLP },

      { from: urBEANLP, to: BEAN },
      { from: urBEANLP, to: BEANLP }
    ])("Unsupported paths", (pair) => {
      const { from, to } = pair;

      it(`Fail ${from.symbol} -> ${to.symbol}`, async () => {
        const fn = async () => sdk.silo.convert(from, to, from.amount(1));
        await expect(fn).rejects.toThrowError("Cannot convert between these tokens");
      });
    });

    describe("DeltaB < 0", () => {
      beforeAll(async () => {
        // Force deltaB < 0
        await utils.setCurveLiquidity(15_000_000, 10_000_000);
      });

      describe.each([
        { from: BEANLP, to: BEAN },
        { from: urBEANLP, to: urBEAN }
      ])("Converts Successfully", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const balanceBefore = await sdk.silo.getBalance(to, account, { source: DataSource.LEDGER });
          const { minAmountOut } = await sdk.silo.convertEstimate(from, to, from.amount(100));
          await sdk.silo.convert(from, to, from.amount(100));
          const balanceAfter = await sdk.silo.getBalance(to, account, { source: DataSource.LEDGER });

          expect(balanceAfter.amount.gte(balanceBefore.amount.add(minAmountOut))).toBe(true);
        });
      });

      describe.each([
        { from: BEAN, to: BEANLP },
        { from: urBEAN, to: urBEANLP }
      ])("Errors correctly", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const fn = async () => await sdk.silo.convert(from, to, from.amount(100));

          await expect(fn).rejects.toThrowError("Cannot convert this token when deltaB is < 0");
        });
      });
    });

    describe("DeltaB > 0", () => {
      beforeAll(async () => {
        // Force deltaB > 0
        await utils.setCurveLiquidity(10_000_000, 15_000_000);
      });

      describe.each([
        { from: BEAN, to: BEANLP },
        { from: urBEAN, to: urBEANLP }
      ])("Converts Successfully", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const balanceBefore = await sdk.silo.getBalance(to, account, { source: DataSource.LEDGER });
          const { minAmountOut } = await sdk.silo.convertEstimate(from, to, from.amount(100));
          await sdk.silo.convert(from, to, from.amount(100));
          const balanceAfter = await sdk.silo.getBalance(to, account, { source: DataSource.LEDGER });

          expect(balanceAfter.amount.gte(balanceBefore.amount.add(minAmountOut))).toBe(true);
        });
      });

      describe.each([
        { from: BEANLP, to: BEAN },
        { from: urBEANLP, to: urBEAN }
      ])("Errors correctly", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const fn = async () => await sdk.silo.convert(from, to, from.amount(100));

          await expect(fn).rejects.toThrowError("Cannot convert this token when deltaB is >= 0");
        });
      });
    });
  });
});

async function deposit(from: Token, to: Token, _amount: number) {
  const amount = from.amount(_amount);
  await utils.setBalance(from, account, amount);
  await from.approveBeanstalk(amount);
  const txr = await sdk.silo.deposit(from, to, amount);
  await txr.wait();
}
